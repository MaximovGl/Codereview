/*CalcTree9. В текстовом файле с именем FN1 дано арифметическое выражение в инфиксной
форме. В выражении могут использоваться операции: сложение(+), вычитание(-), умножение(*),
деление нацело(/), остаток от деления(%), возведение в степень(^), а так же целые числа из про
межутка [1; 30] и переменная x. Для операции возведения в степень показатель степени неотри
цательное целое число. Постройте дерево выражения. После этого вычислите значение выраже
ния при заданном значении переменной x и выведите результат в текстовый файл с именем FN2.
Преобразуйте дерево, заменив все поддеревья вида A+x на x+A, где A - некоторое поддерево, а x - переменная. Распечатайте дерево после преобразования в файл FN2 в префиксной и постфикс
ной форме, а так же в инфиксной форме с избыточными скобками. При наличии нескольких под
ряд идущих одинаковых операций дерево должно строиться по правилу: операции одинакового
приоритета вычисляются по порядку слева направо. Иными словами, выражение 2+3+4+5, напри
мер, должно трактоваться как ((2+3)+4)+5, и не может трактоваться как (2+3)+(4+5) или
2+(3+(4+5)). Результаты всех вычислений, включая промежуточные, принадлежат типу int. */

/**
 * @file expression_tree.h
 * @brief Заголовочный файл для работы с деревьями выражений
 */

#ifndef EXPRESSION_TREE_H
#define EXPRESSION_TREE_H

#include <string>
#include <vector>
#include <fstream>

 /**
  * @brief Узел бинарного дерева выражения
  */
struct Node {
    std::string token;   
    Node* left;          
    Node* right;         
};

/**
 * @brief Разбивает строку выражения на токены
 * @param expr Входное выражение
 * @return Вектор токенов
 */
std::vector<std::string> tokenize(const std::string& expr);

/**
 * @brief Преобразует инфиксную нотацию в постфиксную
 * @param tokens Вектор токенов в инфиксной форме
 * @return Вектор токенов в постфиксной форме
 */
std::vector<std::string> infixToPostfix(const std::vector<std::string>& tokens);

/**
 * @brief Строит дерево выражения из постфиксной нотации
 * @param postfix Вектор токенов в постфиксной форме
 * @return Указатель на корень дерева
 */
Node* buildTree(const std::vector<std::string>& postfix);

/**
 * @brief Вычисляет значение выражения
 * @param root Корень дерева выражения
 * @param x_value Значение переменной x
 * @return Результат вычисления
 */
int evaluate(Node* root, int x_value);

/**
 * @brief Преобразует дерево по правилу A+x -> x+A
 * @param root Корень дерева выражения
 */
void transformTree(Node* root);

/**
 * @brief Печатает дерево в префиксной форме
 * @param root Корень дерева
 * @param fout Выходной файловый поток
 */
void printPrefix(Node* root, std::ofstream& fout);

/**
 * @brief Печатает дерево в постфиксной форме
 * @param root Корень дерева
 * @param fout Выходной файловый поток
 */
void printPostfix(Node* root, std::ofstream& fout);

/**
 * @brief Печатает дерево в инфиксной форме с избыточными скобками
 * @param root Корень дерева
 * @param fout Выходной файловый поток
 */
void printInfix(Node* root, std::ofstream& fout);

/**
 * @brief Удаляет дерево выражения
 * @param root Корень дерева
 */
void deleteTree(Node* root);

/**
 * @brief Обрабатывает выражение: вычисляет, преобразует и выводит результаты
 * @param expression Входное выражение
 * @param x_value Значение переменной x
 * @param outputFile Имя выходного файла
 * @return Код завершения (0 - успех, 1 - ошибка)
 */
int processExpression(const std::string& expression, int x_value,
    const std::string& outputFile);

#endif